\documentclass[10pt]{beamer}

\usepackage[outputdir=latex.out,]{minted}
\usepackage{fontspec}

%% Minted setup (syntax highlighting)
\usemintedstyle{vs}
\setminted{fontsize=\footnotesize}
\newminted[code]{scala}{gobble=0}
\newenvironment{slide}[2][]
  {\begin{frame}[fragile,environment=slide,#1]{#2}}
  {\end{frame}}
\newcommand\makemintedshortinline[2]{%
  \catcode`#2=13
  \begingroup%
  \lccode`\~=`#2
  \lowercase{\endgroup\protected\def~{\mintinline{#1}~}}%
}

%% Beamer theme setup
\usetheme[block=fill]{metropolis}
\setbeamercolor{progress bar}{bg=black, fg=black}
\setbeamercolor{title separator}{bg=black, fg=black}
\setbeamercolor{progress bar in head/foot}{bg=black, fg=black}
\setbeamercolor{progress bar in section page}{bg=black, fg=black}
\setbeamercovered{transparent}

\title{Abstractions for Type-Level Programming}
\date{Tuesday, 22 March 2022}
\author{Olivier Blanvillain}

\makemintedshortinline{scala}\|

\begin{document}

\maketitle

\begin{frame}{Table of contents}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents
\end{frame}

\section[Type-Level Programming\\What? Why?]{What? Why?}

\begin{slide}{Example 1: Database queries (2016)}
Spark API, practically untyped:
\begin{code}
phoneBook                                           : DataFrame
  .innerJoin(cityMap, col("address"))               : DataFrame
  .select(col("name"), col("neighborhood"))         : DataFrame
  .filter(x => uniqueName(x.getAs[String]("name"))) : DataFrame
  .groupBy(col("neighborhood")).count()             : DataFrame
  .sortDesc(col("count"))                           : DataFrame
  .head.getAs[String](0)                            : String
\end{code}
\pause
The same API, revisited with type-level programming:
\begin{code}
phoneBook                          : DF[PhoneBookEntry]
  .innerJoin(cityMap, 'address)    : DF[(Address, String, String, ... )]
  .select('_2, '_3).as[Family]()   : DF[Family]
  .filter(x => uniqueName(x.name)) : DF[Family]
  .groupBy('neighborhood).count()  : DF[(String, Long)]
  .sortDesc('_2)                   : DF[(String, Long)]
  .head._1                         : String
\end{code}
\end{slide}

\begin{slide}{Example 2: Regular expressions (2022)}
Regular expressions in Scala's standard library:
\begin{code}
val rational = new Regex("""(\d+)(?:\.(\d+))?""")
"3.1415" match
  case rational(captures: Seq[String]) =>
    val i = captures(0)
    val j = captures(1)
\end{code}
\pause
The same API, revisited with type-level programming:
\begin{code}
val rational = new R("""(\d+)(?:\.(\d+))?""")
"3.1415" match
  case rational(captures: (String, Option[String])) =>
    val i = captures._1
    val j = captures._2
\end{code}
\end{slide}

\begin{slide}{What changed between 2016 and 2022?}
\begin{itemize}
  \item Example 1 uses a hack, implicits:
  \begin{itemize}
    \item convoluted to use
    \item slow to compile
    \item popular nonetheless
  \end{itemize}
  \pause
  \item Example 2 uses a first-class language construct, match types:
  \begin{itemize}
    \item easier to use
    \item faster to compile
    \item solid theoretical foundation
  \end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{Compilation times for the type-level join operation}
\begin{center}
\input{figures/join.gex}
\end{center}
\end{slide}

\begin{slide}{Compilation times for the type-level join operation, zoomed in}
\begin{center}
\input{figures/join-2.gex}
\end{center}
\end{slide}

\section{Generalizing Scala's Singleton~Types}

\begin{slide}{Singleton types in Scala}
Scala supports a few singleton types:
\begin{itemize}
  \item |x.type|, the type of the variable |x| (since forever)
  \item |42|, the type of the integer literal |42| (since 2016)
  \item |+|, the type of the primitive addition (since 2020)
\end{itemize}
\pause
How much of the language can we lift to the type level?
\end{slide}

\begin{slide}{Generalized singleton types: a proposal}
\end{slide}



\section{Type-Level Programming with Match Types}

\end{document}
