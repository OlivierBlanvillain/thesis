\input{headers.tex}

\begin{document}

\frontmatter
\input{title-page}
\setcounter{page}{0}

\chapter{Acknowledgements}
\lipsum[1-2]
Miles Sabin has been a invaluable help, not only for his work on Shapeless but also for invaluable contribution

\bigskip
\noindent\textit{Lausanne, \today}
\hfill Olivier Blanvillain

\cleardoublepage
\chapter*{Abstract}
\markboth{Abstract}{Abstract}
\addcontentsline{toc}{chapter}{Abstract (English/Français)}
\lipsum[1-2] % max 3499 characters
\begin{otherlanguage}{french}
\cleardoublepage
\chapter*{Résumé}
\markboth{Résumé}{Résumé}
\lipsum[1-2]
\end{otherlanguage}

\hypersetup{linkcolor=black}
\tableofcontents
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures
\hypersetup{linkcolor=purplish}
\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%  Thesis Content  %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{chap:introduction}

In March 2017, our research group went on a ski retreat in the Swiss Alps.
After a full day of skiing on the Diablerets massif, we gathered for a lab dinner.
Denys Shabalin, who was working on Scala Native at the time~\citep{shabalin2020just}, started a conversation about manual memory management.
The discussion revolved around the following question: could a Rust-like ownership system be viable for Scala?
Denys' answer was clear: ownership is fundamentally at odds with the way Scala handles references, and without making deep changes to Scala's type system, the task was simply impossible.

The next day, I came up with a toy domain-specific language (DSL), which implements the basis of a linear type system using type-level programming.
Here is an example of a short program written in this DSL:

\memImplicitMain

\noindent
The type argument of |Context| is a type-level list of strings that corresponds to the memory regions allocated at each program point.
Methods of |Context| use type-level programming techniques to enforce the following properties:

\begin{enumerate}
  \item memory regions must be allocated (|malloc|) \emph{before} they are deallocated (|free|),
  \item all memory regions must be deallocated by the end of the program,
  \item dereferencing (|deref|) is only allowed on previously allocated regions.
\end{enumerate}

\noindent
The implementation makes use of Scala's implicits to enforce these properties.
While this small DSL is obviously too simplistic to be of any practical use, it demonstrates the power of type-level programming.

% 2. Identify the Research Gap
I was delighted with my solution!
Denys, however, was not impressed.
I attribute this apathy to his dislike of implicits.
Despite their widespread usage, implicits are notorious for their complexity~\citep{kvrikava2019scala}.
In particular, using implicits for type-level computations requires carefully crafted definitions following a specific pattern.
To give the reader a glance of this pattern, we show the definition of the |free| method on |Context|:

\memImplicitContextFree

\noindent
This definition uses three parameter lists, one for type parameters (|V| and |Out|), one for a value parameter (|v|), and one of an implicit value parameter (|ev|).
Only the second parameter list is intended to be specified at use site; the type and implicit parameters are meant to be inferred.
When a user writes |.free("mem")| he only sets the |v| parameter (|v="mem"|); the compiler takes care of finding valid assignments for |V|, |Out| and |ev|.
The implicit parameter of type |Remove[V,Ps,Out]| is the entry point to the world of type-level programming, it specifies how |V| (constrained by to be |v|'s type), |Ps| (defined in the class), and |Out| (unconstrained) are interrelated:

\memImplicitRemove

\noindent
Implicit-prefixed definitions can be understood as \emph{facts} and \emph{rules} of a logic program.
The first definition, |casehead|, specifies a fact: the result of removing |V| from the list |V::Ps| is |Ps|, which is expressed as an instance of |Remove[V,V::Ps,Ps]|.
The second definition, |casetail|, specifies a rule: if the result of removing |V| from the list |Pt| is |Out|, the results of removing |V| from the list |Ph::Pt| is |Ph::Out| (\Cref{sec:hlists-remove} develops this example in more details).
When a user writes |ctx.free("mem")| on a |ctx| of type |Context["bool"::"mem"::HNil]|, the compiler uses |casehead| and |casetail| to compute a type |Out| such that |Out| is the results of removing |"mem"| from |"bool"::"mem"::HNil|.

In retrospect, I have to agree with Denys' judgment at the time: this style of programming is convoluted, to say the least.
Aesthetics and pragmatism aside, programming with implicits requires a complete paradigm shift.
Instead using pattern matching and functions, implicits require algorithms to be expressed using relations and constraints, which makes the task harder than it should be.

% 8. State Research Objectives
\emph{Can we do better?} This is the question that motivates the work presented in dissertation.

% 3. State the Background Information
Dependently-typed programming languages, such as Coq~\citep{bertot2004interactive}, Agda~\citep{norell2007towards}, and Idris~\citep{brady2014idris}, make no distinction between terms and types, and thus naturally support type-level programming.
Scala, on the other hand, has a clear separation between its term and type language.

% When terms are types are unified, the distinction between programming and type-level programming blurs out since value-level computations can be performed during type checking.

TLP isn't new. GHC' Haskell is leading the charge with the numerous language extentions developped over the las decate. Unfortunately, many of the techniques developed in the context of Haskell are not directly applicable to other programming languages. In particular, subtying ...

% 9. Create an Outline
% - (Ab)Using Implicits
% - Generalizing Scala's Singleton Types
% - Match Types
% - Performance-Based Evaluation

\lipsum[1]

\chapter{(Ab)Using Implicits}
\label{chap:ab-using-implicits}

Scala's implicit parameters have outgrown their roots as a simple syntactic construct to the extent that they provide basic support for type-level programming.
In this chapter, we present techniques for implicit-based type-level programming in Scala.
In particular, through extended examples, we show how to use Scala's implicit resolution mechanism to \emph{compute} types, in a style that resembles logic programming.

\subsection*{Attribution}

The first section of this chapter is based on the introduction to implicits from \citep{odersky2018simplicitly}, which was written in collaboration with Martin Odersky, Fengyun Liu, Aggelos Biboudis, Heather Miller and Sandro Stucki, and published in POPL'18.

Code samples for the remaining of this chapter are based on the implementation of heterogeneous lists from the Shapeless library \citep{sabin2011shapeless}.

\section{Implicit Parameters: Overview}

\emph{Implicit parameters} offer a convenient way to write code without the need to pass all arguments explicitly.
The ability to omit function arguments gives rise to many interesting coding styles and patterns.
On every call to functions with implicit parameters, the compiler looks for an implicit definition in scope to satisfy the call.
So, instead of passing a parameter explicitly:

\explicitModulo

\noindent
we can mark a set of parameters as implicit (a single parameter in this example) and let the compiler retrieve the missing argument for us.
In the following example, |addm| is a method with one implicit parameter and |modulo| is an implicit definition:

\implicitModulo

The process of implicit parameter discovery performed by the compiler is called \emph{implicit resolution}.
The resolution algorithm looks for implicits in the current scope and in the companion objects of all classes associated with the query type.
In the previous example, the implicit definition is declared in the current scope.
Since that definition has type |Int|, the compiler resolves the method call by passing |modulo| automatically.

\subsubsection{The type class pattern}

Implicits can be used to implement type classes~\citep{wadler1989how} as a design pattern~\citep{oliveira2010type}.
We give an example of an implementation of the |Ordering| type class.
This example consists of three parts:

\begin{enumerate}
  \item |Ordering[T]|, which is a regular trait with a single method, |compare|,
  \item the generic function |comp|, which compares two arguments and accepts an implicit argument, providing an \emph{implicit evidence} that these two values can be compared,
  \item the implicit definition |intOrdering|, which provides an \emph{instance} of the |Ordering| type class for integers.
\end{enumerate}

\ordExample

We have briefly introduced implicit parameters and showed how they can be used to avoid clutter in function applications.
In the next section, we present recursive implicit resolution.

\section{Recursive Implicit Resolution}

Implicit methods can themselves take implicit parameters.
For example, we can define the lexicographic list ordering as follows:

\ordListExample

\noindent
This definition is parametrized by the list's element type and by an ordering of that type, passed as an implicit parameter.
Since |listOrdering| is itself implicit, it defines a \emph{rule}: it allows the compiler to materialize an implicit |Ordering[List[T]]|, given an implicit |Ordering[T]| (for any type |T|).

Parametrized implicit definitions can lead to recursive implicit resolution. For example, the compiler will use |listOrdering| twice to synthesize an implicit |Ordering[List[List[T]]]|.
This is where the (type-level) fun begins!

\subsubsection{Heterogeneous lists}

A heterogeneous list, or |HList| for short~\citep{kiselyov2004strongly}, is a datatype capable of storing data of different types.
In Scala 3, we can define the |HList| datatype as follows:

\hlistEnumDefinition

\noindent
The |::| constructor offers an interesting symmetry between the term and type level, which allows |HList| types to capture the same structure that their term-level counterparts.
For example, the term |::(1,::(2,HNil()))| can be typed as |::[1,::[2,HNil]]|, which is a perfect reification of that term (we use literal singleton types to represent constant literals at the type level~\citep{leontiev2014sip}).

\subsubsection{HList's remove}
\label{sec:hlists-remove}

Scala's implicits allow us to define type-level operations for heterogeneous lists.
We develop the example presented in \Cref{chap:introduction} by looking into the type-level remove operation on |HList|s.
The remove operation takes as argument an element and a list, and returns that list with the first occurrence of the element removed.
This operation should yield an error if the element is not part of the list.

An implicit-based type-level operation typically takes the form of a trait, the operation's entry point, and several implicit definitions, one for each "case" of the operation's algorithm.
Let us consider the implementation of the remove operation in more detail:

\memImplicitRemove

\noindent
The |Remove| trait takes 3 type parameters: 2 inputs, |V| (the element to remove) and |Ps| (the list), and one output, |Out| (the list, with the element removed).
The two implicit definitions, |casehead| and |casetail|, correspond to the base case and the recursive case of the list removal operation, respectively.
The |Remove| trait is intended to be used as an implicit parameter, with constrained input types, and an unconstrained output type.

When the given element is not part of the list, implicit resolution fails with an "implicit not found" error, which indicates the incorrect use of |Remove|.
More precisely, the implicit search first iterates through the list by repeatedly using |casetail| until it reaches the end of the list, at which point it fails to find an implicit value of type |Remove[V,HNil,Out]| (neither |casehead| nor |casetail| produce an instantiation of |Remove| with |Ps=HNil|).

As an example usage of |Remove|, consider the following stringly-typed, JavaScript-inspired method:

\addEventListenerJS

\noindent
This method's documentation specifies 5 valid alternatives for the |event| argument, but that constraint is not reflected in the method's type signature.
In JavaScript, calling this method with an erroneous element event type is a \emph{no-op}, which can make this kind of error particularly hard to spot.

Instead of specifying that constraint in the documentation, we can represent the valid event types in a |HList|, and use an implicit parameter of type |Remove| to statically enforce that property:

\addEventListenerImplicitDef

\noindent
The |Singleton| type bound is a marker that instructs type inference to preserve literal singleton types (by default, the compiler widens those types).
The "|?|" type is Scala 3's new syntax for wildcard types~\citep{dotty2014wildcard}.

With this updated signature, the compiler is able to detect invalid event types at compile time.
When given a valid event type |E|, the compiler synthesizes an implicit evidence of type |Remove[E,EventTypes,?]| which witnesses |E|'s validity.
After implicit resolution, calls to the |addEventListener| method are expanded to automatically insert an implicit parameter for the second parameter list, such as in the following example:

\addEventListenerImplicitCall

This concludes our presentation of the implicit-based encoding of type-level computation.
Despite its verbosity, this pattern generalizes to arbitrary recursive computations and enables Scala programmers to write elaborate type-level programs solely based on implicits.
In the next section, we discuss ambiguities and priorities between implicit definitions.

\section{Ambiguities and Priorities}

Scala's implicit resolution relies on an intricate priority system to establish the precedence of implicit definitions.
Implicit-based programs sometimes rely on ambiguities and priorities of implicit definition, as we will see in this section through a series of example.

\subsection{Implicit Ambiguities}

The Scala compiler rejects programs with \emph{ambiguous} implicit definition.
For instance, if we write two identically-typed implicit definitions in the same scope, the compiler will consider them ambiguous and report an error:

\implicitAmbiguity

While ambiguities typically indicate programming errors, we can also use them purposefully to implement the error case of a type-level program.
As an example, consider the |NotIn| operation on |HList| that is only defined if the given element is \emph{not} part of the list.
We define |NotIn| using two ambiguous implicits; the implementation is lengthy, but straightforward:

\memImplicitNotIn

\noindent
The |casenil| and |casecons| implicits simply iterate through the list.
The |ambiguous| implicits are two identical definitions that will cause the compiler to raise an error if |V| and |Ph| are equal, for any element |Ph| of the list ("|=:=|" is a type from Scala's standard library that witnesses mutual subtyping).

As an example usage of |NotIn|, we revisit the DSL presented in \Cref{chap:introduction}.
Programs in our DSL consist of sequences of method calls on a |Context|, which tracks the memory regions that are currently allocated in the program, using a |HList| of names.
We use the |NotIn| operation to constrain the allocation method, |malloc|, to prevent allocating regions with already used names:

\memImplicitContextMalloc

Scala 3 introduced an alternative to the ambiguous implicit pattern in the form of the |scala.util.NotGiven| type~\citep{dotty2014given}.
The compiler will synthesize an implicit parameter of type |NotGiven[T]|, if and only if there is no implicit value of type |T| in scope.
We can use a "negative" implicit evidence to simplify the definition of |NotIn| by removing the ambiguous implicits and changing |casecons| to the following:

\memImplicitNotGiven

\subsection{Implicit Priorities}

When looking for implicits, the Scala compiler visits scopes sequentially, in a precisely defined order.
At any point in the search, if the implicits defined in the subset of scopes considered so far can fulfill the implicit query, the search succeeds and immediately terminates.
This incremental process has two consequences.
First, it allows the compiler to efficiently look for implicits by naturally pruning some of the search space.
Second, it provides an ad-hoc mechanism to disambiguate implicits.
Scala programmer can artificially partition their implicit definitions into multiple scopes to implement a priority system.

Let us consider an example of operation on |HList| whose implementation uses implicit priorities.
|RemoveAll| is a generalization of |Remove| that removes every occurrence of the given element instead of the first occurrence.
The implicit-based implementation takes the form of a trait with 3 type parameters: 2 inputs, |V| (the element to remove) and |Ps| (the list), and one output, |Out| (the list, with the elements removed):

\removeAllDefinition

From an algorithmic standpoint, we can implement |RemoveAll| as a recursive function with 3 cases, a base case for the empty list (|casenil|), a recursive case for when the head of the list matches the element to remove (|casematch|), and another recursive case for when the head doesn't match (|casedoesnt|):

\removeAllBroken

This direct implementation of |RemoveAll| using implicit definitions is, unfortunately, incorrect.
The issue is that the |casematch| and |casedoesnt| definitions are ambiguous when the head of the list matches the element to remove.
To work around that ambiguity, we split those definitions into two different scopes, so that the compiler always tries to apply the more specialized case (|casematch|) before considering the less specialized case (|casedoesnt|).
Concretely, we define low priority implicits in a separate trait, and have |RemoveAll|'s companion object extend that trait:

\removeAllPrioritized

\section{Conclusion}

In this chapter, we presented several techniques to program at the type-level with implicits.
This style of programing is, unfortunately, quite cumbersome.
In addition to the heavy syntax, type-level programing with implicits also requires a deep understanding of the implicit resolution algorithm.
As we will see in \Cref{chap:performance-based-evaluation}, the usability of those techniques also suffers from the massive impact they have on compilation time.
Yet, despite those shortcoming, Scala programmers have...

\chapter{Generalizing Scala's Singleton Types}
\label{chap:generalizing-scala-s-singleton-types}
\subsection*{Attribution}
\citep{schmid2020coming}
\input{preprint.tex}

\chapter{Match Types}
\label{chap:match-types}

Type-level programming is becoming more and more popular in the realm of functional programming.
However, the combination of type-level programming and subtyping remains largely unexplored in practical programming languages.
This chapter presents \emph{match types}, a type-level equivalent of pattern matching.
Match types integrate seamlessly into programming languages with subtyping and, despite their simplicity, offer significant additional expressiveness.
We formalize the feature of match types in a calculus based on \SystemFsub and prove its soundness.
We practically evaluate our system by implementing match types in the Scala 3 reference compiler, thus making type-level programming readily available to a broad audience of programmers.

\subsection*{Attribution}

This chapter is based on \citep{blanvillain2022type}, which was written in collaboration with Jonathan Brachthäuser, Maxime Kjaer and Martin Odersky, and published in POPL'22.

\input{article.tex}

\chapter{Performance-Based Evaluation}
\label{chap:performance-based-evaluation}

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/concat.gex}
  \end{subfigure}%
  \hspace{-20pt}
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/remove.gex}
  \end{subfigure}

  \vspace{-2pt}
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/join.gex}
  \end{subfigure}%
  \hspace{-20pt}
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/numpy.gex}
  \end{subfigure}
  % \caption{#1}
  % \label{fig:dependentVsImplicitBenchmarks}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/concat-2.gex}
  \end{subfigure}%
  \hspace{-20pt}
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/remove-2.gex}
  \end{subfigure}

  \vspace{-2pt}
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/join-2.gex}
  \end{subfigure}%
  \hspace{-20pt}
  \begin{subfigure}[t]{0.5\textwidth}
      \centering
      \input{figures/numpy-2.gex}
  \end{subfigure}
  % \caption{#1}
  % \label{fig:dependentVsImplicitBenchmarks}
\end{figure}


\begin{table*}
  \centering
  \caption{Additional JVM Bytecode generated\\per benchmark size increment (in Bytes)}
  \label{tab:bytecode}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{@{}lrrr@{}}
  \toprule & Implicits & Generalized Singletons & Match Types \\
  \midrule
  Concat     & 6  & 0 & 0 \\
  Remove     & 6  & 0 & 0 \\
  ReduceAxes & 12 & 0 & 0 \\
  Join       & 18 & 0 & 0 \\
  \bottomrule
  \end{tabular}
\end{table*}

\begin{enumerate}
  \item Concat
  \item Remove
  \item Join
  \item ReduceAxes
\end{enumerate}


\lipsum[1]

\chapter{Conclusion}
\label{chap:conclusion}
\lipsum[1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%  Bibliography, Appendix, CV  %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\chapter{Type Soundness for System FM}
\renewenvironment{proof}{{\it Proof: }}{\qed} % Show proofs
\input{proofs/permutation.tex}
\input{proofs/weakening.tex}
\input{proofs/strengthening.tex}
\input{proofs/substitution.tex}
\input{proofs/disjointness-subtyping-exclusivity.tex}

\harpoonx{Definition of the auxiliary relation $\protect \⇌$, used to state inversion of subtyping.}

\begin{definition*}
  $\Γ \⊢ \S \⇌ \T$ (defined in \Cref{fig:harpoon}) represents evidence of the mutual subtyping between a match type $\S$ and a type $\T$ with the additional constraint that this evidence was exclusively constructed using pairwise applications of \emph{\SMatch1/2}, \emph{\SMatch3/4}, and \emph{\STrans} in both directions.
\end{definition*}

\input{proofs/inversion-of-subtyping.tex}
\input{proofs/canonical-forms.tex}
\input{proofs/inversion-of-typing.tex}
\input{proofs/minimum-types.tex}
\input{proofs/preservation.tex}
\input{proofs/progress.tex}

\backmatter
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{apalike}
\bibliography{bibliography}

\cleardoublepage
\thispagestyle{empty}
\phantomsection
\addcontentsline{toc}{chapter}{Curriculum Vitae}
\includepdf{olivier-blanvillain-resume.pdf}
\thispagestyle{empty}~

\end{document}
