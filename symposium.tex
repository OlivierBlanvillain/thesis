\section{Introduction}

The Scala standard library includes a package to manipulate regular expressions.
This package is based on Java's implementation of regular expression, and thus benefits from the high performance of the JVM's regex engine.
The Scala implementation innovates with its presentation: it uses the power and flexibility of Scala's pattern matching to offer a syntax that is both elegant and concise.
The package's documentation starts with the following example:

\regexDocumentation
% val date = new Regex("(\\d{4})-(\\d{2})-(\\d{2})")
% "2004-01-20" match
%   case date(year, month, day) =>
%     s"$year was a good year for PLs."

\noindent
The extractor pattern, |case date(y,m,d) =>|, replaces the need for manually indexing into the regular expression's capturing groups, and shields its users from off-by-one error.

While the syntax of this example would undoubtedly make some non-Scala programmers envious, its type safety leaves much to be desired.
First of all, the \emph{number} of variable bindings in the extractor is entirely opaque to Scala's type system, and left to the discretion of the programmer.
Furthermore, the values coming out of capturing groups can be null (when using optional captures) and thus require an additional layer of validation.
Those shortcomings might appear benign when looking at small examples, but can easily turn into bugs when dealing with a large-scale code base.

In this chapter, we propose a new design for Scala's regular expression library which provides both type-safe and null-safe capturing group extraction.
Our design makes extensive use of match types, Scala~3 new feature for type-level programming, to statically analyze regular expressions during type checking and generate type-specialized extractors.
We build our interface to mimic Scala's original regular expression API so that Scala programmers can use it as a drop-in replacement while still enjoying additional safety.

\section{Architecture}

We present our library in terms of 3 components:

\begin{enumerate}
  \item The type-level capturing group analysis, which uses match types to inspect the user-provided regular expression and compute the corresponding tuple-based type representation (\Cref{sec:type-level}).

  \item The term-level capturing group processing, which extracts and sanitizes the output of the regex engine, in accordance with the representation computed by the type-level component (\Cref{sec:term-level}).

  \item The user interface, which ties everything together to compile, execute, and extract the results of a regular expression, while providing type-safe and null-safe capturing group extraction.
\end{enumerate}

We begin our presentation with the user interface, which takes the form of a relatively simple Scala class and companion object:

\regexUserLevel
% object Regex:
%   def apply[R <: String & Singleton](regex: R): Regex[Compile[R]] =
%     new Regex(regex)
%
% class Regex[P] private (val regex: String):
%   val pattern = Pattern.compile(regex)
%   def unapply(s: String): Option[P] =
%     val m = pattern.matcher(s)
%     if (m.matches())
%       val a = Array.tabulate(m.groupCount) { i => m.group(i + 1) }
%       Some(toTuple[P](regex, a))
%     else
%       None

The |apply| method is the entry point of our library.
It takes a regular expression and returns an instance of |Regex|.
Instead of directly accepting |String| argument, that method requires a type parameter, |R|, which will be inferred by the compiler, and allows us to get our hands on a type-level instance of the regular expression (the |Singleton| bound is necessary to guide Scala's type inference).
We use that type-level string immediately to instantiate |Compile|, which is our type-level capturing group analysis component.
We store the output of that analysis as |Regex|'s type argument.

The implementation of the |Regex| class is straightforward.
Similar to its standard library counterpart, that class uses an instance of |java.util.regex.Pattern| to match the given input against the regular expression, and to extract the capturing groups whenever the matching succeeds.
The |Regex| class defines an |unapply| method, which the Scala compiler will invoke when using an instance of that class as a pattern matching extractor \citep{emir2007matching}.

The main difference between Scala's original |Regex| implementation and ours lies in the signature of the |unapply| method, which determines the nature of extraction performed by that method.
By returning an optional tuple, we tell the compiler that a successful matching consists of exactly $n$ capturing groups, where $n$ corresponds to the tuple arity, and that the type of those groups will correspond to the tuple types.
We take advantage of that flexibility to enrich the results of Java's regex engine by wrapping nullable values into options.
In our implementation, this is done via the |toTuple| method, which is our
term-level capturing group processing component.
As a result, our implementation never returns null values, which removes the null-checking burden from the user.

For instance, in the following example, we use a regular expression with an optional capturing group to extract the integral and fractional parts of a rational number:

\regexRational
% val rational = Regex("(\\d+)\\.?(\\d+)?")
% "3.1415" match
%   case rational(i, Some(f)) =>
%     val n = i.size + f.size
%     s"This number is $n digits long"

\noindent
Here, we instantiates |Regex|'s type parameter to |P = (String, Option[String])|, which we then use in |unapply|'s return type to obtain a precise representation of the regex's capturing groups.

\section{Type-Level}
\label{sec:type-level}

The purpose of our type-level component is two-fold:

\begin{enumerate}
  \item Identify the capturing groups of the input regular expression.
  \item Determine which of those capturing groups are optional, that is, whether or not the regex engine can assign null values for each of those groups.
\end{enumerate}

\noindent
The result of that type-level computation takes the form of a Scala tuple with |String| and |Option[String]| elements, depending of the nullability analysis.

We present our implementation incrementally, starting from a simple but incomplete solution, and progressively building up towards our final solution.

\subsection{Capture Group Identification}

The first version of our type-level program is limited to capturing group identification.
The implementation is straightforward, it iterates through the regex's characters and accumulates a |String| type for every opening parenthesis:

\regexFirstIteration
% import compiletime.ops.string._
% import compiletime.ops.int.+
%
% type Compile[R <: String] =
%   Reverse[Loop[R, 0, Length[R], EmptyTuple]]
%
% type Loop[R <: String, Lo <: Int, Hi <: Int, Acc <: Tuple] <: Tuple =
%   Lo match
%     case Hi => Acc
%     case _  => CharAt[R, Lo] match
%       case "("  => Loop[R, Lo + 1, Hi, String *: Acc]
%       case "\\" => Loop[R, Lo + 2, Hi, Acc]
%       case _ => Loop[R, Lo + 1, Hi, Acc]

\noindent
The |Length| and |CharAt| types are special-cased by the compiler: when their first argument is a literal singleton string, the compiler evaluates those types via their corresponding term-level implementation.
Similarly, the |+| type (from |compiletime.ops.int|) allows us to manipulate integers just like we would at the term level.
The |EmptyTuple| and |*:| are Scala~3's new generic representation of tuples.
Those types remove the need for heterogeneous lists and lets us manipulate tuples directly.

\subsection{Out-Of-Bound Errors}

Attentive readers might have noticed that our handling of backslash, regex's escape character, might lead to off-by-one errors.
Be reassured, this is not an oversight!
Regular expressions with trailing backslashes result in runtime exceptions (reported as "unexpected internal error").
Even though detecting these types of errors at compile time is out of the scope of our implementation, doing so is still desirable.
If we invoke |Compile| on a regular expression with a trailing backslash, the compiler will run into a call to |charAt| with an out of bounds argument, catch the corresponding exception and report it as a compilation error.

\subsection{Non-Capturing Groups}

Our first implementation of |Compile| treats every opening parenthesis as the start of a capturing group, which does not do honor to the syntax of Java's regular expression.
Indeed, Java also supports several other special constructs which start with an opening parenthesis, for instance:

\begin{itemize}
  \item non-capturing groups, |(?:X)|,
  \item lookaheads, |(?=X)| and |(?!X)|,
  \item lookbehinds, |(?<=X)| and |(?<!X)|.
\end{itemize}

\noindent
To correctly identify capturing groups (which can be either named, |(?<name>X)|, or unnamed, |(X)|), we must differentiate them from other special constructs.
Our second implementation (omitted) uses the following |IsCapturing| predicate type to rule out non-capturing groups:

\regexIsCapturing
% type IsCapturing[R <: String, At <: Int] <: Boolean =
%   CharAt[R, At] match
%     case "?" => CharAt[R, At + 1] match
%       case "<" => CharAt[R, At + 2] match
%         case "!" => false // zero-width negative lookbehind
%         case _ => true    // named-capturing group
%       case _ => false     // other non-capturing special constructs
%     case _ => true        // unnamed-capturing group

\noindent
Similar to our handling of backslash characters, this implementation intentionally does not guard against out-of-bounds errors, since these errors correspond to ill-formed regular expressions.

\subsection{Nullability Analysis}

Establishing the nullability of capturing groups is more complicated than it sounds.
At first glance, it seems that this is simply a matter of looking for regex quantifiers in suffix position\footnote{
For brevity, our presentation does not account for the regex alternative operator, which also influences the nullability of capturing groups and can appear in both prefix and suffix positions.
In our implementation, we do account for that operator, which we handle analogously.
}.
For instance, in the following naive implementation of |IsNullable|, we look for the first closing parenthesis and inspect the following characters to determine if a capturing group is nullable:

\regexNaiveIsNullable
% type IsNullable[R <: String, At <: Int, Hi <: Int] <: Boolean =
%   CharAt[R, At] match
%     case ")" => IsMarked[R, At + 1, Hi]
%     case _   => IsNullable[R, At + 1, Hi]
%
% type IsMarked[R <: String, At <: Int, Hi <: Int] <: Boolean =
%   At match
%     case Hi => false
%     case _ =>
%       CharAt[R, At] match
%         case "?" | "*" => true
%         case "+" => IsMarked[R, At + 1, Hi]
%         case _ => false

\noindent
Unfortunately, this naive solution is incorrect for regular expressions with nested capturing groups.
For example, in |(A(B)?)|, that solution incorrectly labels the first group as optional.
To overcome this problem, we update our solution to keep track of the number of opening and closing parentheses (|Lvl|), which allows us to differentiate closing parentheses of inner groups from the closing parenthesis of the outer group:

\regexIsNullable
% type IsNullable[R <: String, At <: Int, Hi <: Int, Lvl <: Int] <: Boolean =
%   CharAt[R, At] match
%     case ")" => Lvl match
%       case 0 => IsMarked[R, At + 1, Hi]
%       case _ => IsNullable[R, At + 1, Hi, Lvl - 1]
%     case "(" => IsNullable[R, At + 1, Hi, Lvl + 1]
%     case "\\" => IsNullable[R, At + 2, Hi, Lvl]
%     case _    => IsNullable[R, At + 1, Hi, Lvl]

Nested capturing groups bring another complication to the nullability analysis, which is caused by the interaction between inner and outer groups.
When an outer group is deemed optional, this overrides the nullability of all its inner groups, which also become optional.
For instance, in |(A(B))?|, both the first (|A(B)|) and the second (|B|) capturing group are optional.

The final iteration of our type-level program handles nested groups by operating in two different modes.
While iterating through the regex's characters, our algorithm can either be outside of an optional group (|Lvl=0|), or inside an option group (|Lvl>0|), in which case it overrides the nullability of newly encountered groups.
Our implementation is as follows (|IsCapturing| omitted for brevity):

\regexLastIteration
% type Loop[R <: String, Lo <: Int, Hi <: Int, Acc <: Tuple, Lvl <: Int] =
%   Lo match
%     case Hi => Acc
%     case _  => CharAt[R, Lo] match
%       case ")" => Loop[R, Lo + 1, Hi, Acc, Max[0, Lvl - 1]]
%       case "(" =>
%         Lvl match
%           case 0 => IsNullable[R, Lo + 1, Hi, 0] match
%             case true  => Loop[R, Lo + 1, Hi, Option[String] *: Acc, 1]
%             case false => Loop[R, Lo + 1, Hi, Acc, 0]
%           case _ => Loop[R, Lo + 1, Hi, Option[String] *: Acc, Lvl + 1]
%       case "\\" => Loop[R, Lo + 2, Hi, Acc, Lvl]
%       case _ => Loop[R, Lo + 1, Hi, Acc, Lvl]

\section{Term-Level}
\label{sec:term-level}

In this section...

\section{Evaluation}

In this section...
