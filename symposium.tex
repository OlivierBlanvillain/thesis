\section{Introduction}

The Scala standard library includes a package to manipulate regular expressions.
This package is based on Java's implementation of regular expression, and thus benefits from the high performance of the JVM's regex engine.
The Scala implementation innovates with its presentation: it uses the power and flexibility of Scala's pattern matching to offer a syntax that is both elegant and concise.
The package's documentation starts with the following example:

\regexDocumentation
% val date = new Regex("(\\d{4})-(\\d{2})-(\\d{2})")
% "2004-01-20" match
%   case date(year, month, day) =>
%     s"$year was a good year for PLs."

\noindent
The extractor pattern, |case date(y,m,d) =>|, replaces the need for manually indexing into the regular expression's capture groups, and shields its users from off-by-one error.

While the syntax of this example would undoubtedly make some non-Scala programmers envious, its type safety leaves much to be desired.
First of all, the \emph{number} of variable bindings in the extractor is entirely opaque to Scala's type system, and left to the discretion of the programmer.
Furthermore, the values coming out of capture groups can be null (when using optional captures) and thus require an additional layer of validation.
Those shortcomings might appear benign when looking at small examples, but can easily turn into bugs when dealing with a large-scale code base.

In this chapter, we propose a new design for Scala's regular expression library which provides both type-safe and null-safe capture group extraction.
Our design makes extensive use of match types, Scala~3 new feature for type-level programming, to statically analyze regular expressions during type checking and generate type-specialized extractors.
We build our interface to mimic Scala's original regular expression API so that Scala programmers can use it as a drop-in replacement while still enjoying additional safety.

\section{Architecture}

We present our library in terms of 3 components:

\begin{enumerate}
  \item The type-level capture group analysis, which uses match types to inspect the user-provided regular expression and compute the corresponding tuple-based type representation (\Cref{sec:type-level}).

  \item The term-level capture group processing, which extracts and sanitizes the output of the regex engine, in accordance with the representation computed by the type-level component (\Cref{sec:term-level}).

  \item The user-level interface, which ties everything together to compile, execute, and extract the results of a regular expression, while providing type-safe and null-safe capture group extraction.
\end{enumerate}

We begin our presentation with the user-level interface, which takes the form of relatively simple Scala class and companion object:

\regexUserLevel
% object Regex:
%   def apply[R <: String & Singleton](regex: R): Regex[Compile[R]] =
%     new Regex(regex)
%
% class Regex[P] private (val regex: String):
%   val pattern = Pattern.compile(regex)
%   def unapply(s: String): Option[P] =
%     val m = pattern.matcher(s)
%     if (m.matches())
%       val a = Array.tabulate(m.groupCount) { i => m.group(i + 1) }
%       Some(toTuple[P](regex, a))
%     else
%       None

The |apply| method is the entry point of our library.
It takes a regular expression and returns an instance of |Regex|.
Instead of directly accepting |String| argument, that method requires a type parameter, |R|, which will be inferred by the compiler, and allows us to get our hands on a type-level instance of the regular expression (the |Singleton| bound is necessary to guide Scala's type inference).
We use that type-level string immediately to instantiate |Compile|, which is our type-level capture group analysis component.
We store the output of that analysis as |Regex|'s type argument.

The implementation of the |Regex| class is straightforward.
Similarly its counterpart in the original Scala implementation, that class uses an instance of |java.util.regex.Pattern| to match the given input against the regular expression, and to extract the capture groups whenever the matching succeeds.
The |Regex| class defines an |unapply| method, which the Scala compiler will invoke when using an instance of that class as a pattern matching extractor \citep{emir2007matching}.

The main difference between Scala's original |Regex| implementation and ours lies in the signature the |unapply| method, which determines the nature of extraction performed by that method.
By returning an optional tuple, we tell the compiler that a successful matching consists of exactly $n$ capture groups, where $n$ corresponds to the tuple arity, and that the type of those groups will correspond to the tuple types.
We take advantage of that flexibility to enrich the results of Java's regex engine by wrapping nullable values into options.
In our implementation, this is done via the |toTuple| method, which is our
term-level capture group processing component.
As a result, our implementation never returns null values, which removes the null-checking burden of from the user.

For instance, in the following example, we use a regular expression with an optional capture group to extract the integral and fractional parts of a rational number:

\regexRational
% val rational = Regex("(\\d+)\\.?(\\d+)?")
% "3.1415" match
%   case rational(i, Some(f)) =>
%     val n = i.size + f.size
%     s"This number is $n digits long"

\noindent
Here, we instantiates |Regex|'s type parameter to |P = (String, Option[String])|, which we then use in |unapply|'s return type to obtain a precise representation of the regex's capture groups.

\section{Type-Level}
\label{sec:type-level}

The purpose of our type-level component is two-fold:

\begin{enumerate}
  \item Identify the capture groups of the input regular expression.
  \item Determine which of those capture group are optional, that is, whether or not the regex engine can assign null values for each of those groups.
\end{enumerate}

\noindent
The result of that type-level computation takes the form of a Scala tuple with |String| and |Option[String]| element, depending of the optionality analysis.

We present our implementation incrementally, starting from simple but incomplete solution, and progressively building up towards our final solution.
The first version of our type-level program is limited to capture group identification.
The implementation is straightforward:

\begin{lstlisting}
import compiletime.ops.string.{Length, CharAt}
import compiletime.ops.int.+

type Compile[R <: String] =
  Reverse[Loop[R, 0, Length[R], EmptyTuple]]

type Loop[R <: String, Lo <: Int, Hi <: Int, Acc <: Tuple] <: Tuple =
  Lo match
    case Hi => Acc
    case _   => CharAt[R, Lo] match
      case '('  => Loop[R, Lo + 1, Hi, String *: Acc]
      case '\\' => Loop[R, Lo + 2, Hi, Acc]
      case _ => Loop[R, Lo + 1, Hi, Acc]
\end{lstlisting}

\noindent
The |Length| and |CharAt| types are special cased by the compiler: when their first argument is a literal singleton string, the compiler evaluates those types via their corresponding term-level implementation.
Similarly, the |+| type from |compiletime.ops.int| allows us to manipulate integer just like we would at the term level.
The |EmptyTuple| and |*:| are Scala~3's new generic representation of tuples.
Those types remove the need for heterogeneous lists and allow us to manipulate tuples directly.

Attentive readers might have noticed that our handling of backslash, regex's escape character, might lead to off-by-one errors.
Be reassured, this is not an oversight!
Regular expressions with trailing backslashes result in runtime exceptions (reported as "unexpected internal error").
Even though detecting there type of error at compile time is out of the scope of our implementation, doing so is still desirable.
If we invoke |Compile| on a regular expression with a trailing backslash, the compiler will run into an call to |charAt| with an out of bounds argument, catch the corresponding exception and report it as a compilation error.

Our first implementation of |Compile| treats every opening parethesis as the start of a capture group, which does no do honor syntax of Java's regular expression.
Indeed, Java also support several other special constructs which start with an opening parethesis, such as non-capturing groups, |(?:X)|, lookaheads, |(?=X)| \& |(?!X)|, and lookbehinds, |(?<=X)| \& |(?<!X)|, and must all be discriminated from named and unnamed-capturing groups, |(?<name>X)| \& |(X)|.

\regexIsCapturing
% type IsCapturing[R <: String, At <: Int] =
%   CharAt[R, At] match
%     case "?" => CharAt[R, At + 1] match
%       case "<" => CharAt[R, At + 2] match
%         case "!" => false // zero-width negative lookbehind
%         case _ => true    // named-capturing group
%       case _ => false     // other non-capturing special constructs
%     case _ => true        // unnamed-capturing group

\section{Term-Level}
\label{sec:term-level}

In this section...

\section{Evaluation}

In this section...
