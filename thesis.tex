\input{headers.tex}

\begin{document}

\frontmatter
\input{title-page}
\setcounter{page}{0}

\chapter{Acknowledgements}
\lipsum[1-2]

\bigskip
\noindent\textit{Lausanne, \today}
\hfill Olivier Blanvillain

\cleardoublepage
\chapter*{Abstract}
\markboth{Abstract}{Abstract}
\addcontentsline{toc}{chapter}{Abstract (English/Français)}
\lipsum[1-2] % max 3499 characters
\begin{otherlanguage}{french}
\cleardoublepage
\chapter*{Résumé}
\markboth{Résumé}{Résumé}
\lipsum[1-2]
\end{otherlanguage}

\hypersetup{linkcolor=black}
\tableofcontents
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures
\hypersetup{linkcolor=purplish}
\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%  Thesis Content  %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{chap:introduction}

In March 2017, our research group went on a ski retreat in the Swiss Alps.
After a full day of skiing on the Diablerets massif, we gathered for a lab dinner.
Denys Shabalin, who was working on Scala Native at the time \citep{shabalin2020just}, started a conversation about manual memory management.
The discussion revolved around the following question: could a Rust-like ownership system be viable for Scala?
Denys' answer was clear: ownership is fundamentally at odds with the way Scala handles references, and without making deep changes to Scala's type system, the task was simply impossible.

The next day, I came up with a toy domain-specific language (DSL), which implements the basis of a linear type system using type-level programming.
Here is an example of a short program written in this DSL:

\memImplicitMain

\noindent
The type argument of |Context| is a type-level list of strings that corresponds to the memory regions allocated at each program point.
Methods of |Context| use type-level programming techniques to enforce the following properties:

\begin{enumerate}
  \item memory regions must be allocated (|malloc|) \emph{before} they are deallocated (|free|),
  \item all memory regions must be deallocated by the end of the program,
  \item dereferencing (|deref|) is only allowed on previously allocated regions.
\end{enumerate}

\noindent
The implementation makes use of Scala's implicits to enforce these properties.
While this small DSL is obviously too simplistic to be of any practical use, it demonstrates the power of type-level programming.

% 2. Identify the Research Gap
I was delighted with my solution!
Denys, however, was not impressed.
I attribute this apathy to his dislike of implicits.
Despite their widespread usage, implicits are notorious for their complexity \citep{filip2019implicits}.
In particular, using implicits for type-level computations requires carefully crafted definitions following a specific pattern.
To give the reader a glance of this pattern, we show the definition of the |free| method on |Context|:

\memImplicitContext

\noindent
This definition uses three parameter lists, one for type parameters (|V| and |Out|), one for a value parameter (|v|), and one of an implicit value parameter (|ev|).
Only the second parameter list is intended to be specified at use site; the type and implicit parameters are intended to be inferred.
When a user writes |.free("mem")| he only sets the |v| parameter (|v="mem"|); the compiler takes care of finding valid assignments for |V|, |Out| and |ev|.
The implicit parameter of type |Remove[V, Ps, Out]| is the entry point to the world of type-level programming, it specifies how |V| (constrained by to be |v|'s type), |Ps| (defined in the class), and |Out| (unconstrained) are interrelated:

\memImplicitRemove

\noindent
Implicit-prefixed definitions can be understood as \emph{facts} and \emph{rules} of a logic program.
The first definition, |casehead|, specifies a fact: the result of removing |V| from the list |V::Ps| is |Ps|, which is expressed as an instance of |Remove[V, V::Ps, Ps]|.
The second definition, |casetail|, specifies a rule: if the result of removing |V| from the list |Pt| is |Out|, the results of removing |V| from the list |Ph::Pt| is |Ph::Out| (which is expressed as in instance of |Remove[V, Ph::Pt, Ph::Out]|).
When a user writes |ctx.free("mem")| on a |ctx| of type |Context["bool"::"mem"::HNil]|, the compiler uses |casehead| and |casetail| to compute a type |Out| such that |Out| is the results of removing |"mem"| from |"bool"::"mem"::HNil|.

In retrospect, I have to agree with Denys' judgment at the time: this style of programming is convoluted, to say the least.
Aesthetics and pragmatism aside, programming with implicits requires a complete paradigm shift.
Instead using pattern matching and functions, implicits require algorithm to be expressed using relations and constraints, which makes the task harder than it should be.

\emph{Can we do better?} This is the question that motivates the work presented in dissertation.

% 3. State the Background Information
Dependently-typed programming languages, such as Coq \citep{bertot2004interactive}, Agda \citep{norell2007towards}, and Idris \citep{brady2015idris}, make no distinction between terms and types, and thus naturally support type-level programming.
Scala, on the other hand, has a clear separation between its term and type language.

% When terms are types are unified, the distinction between programming and type-level programming blurs out since value-level computations can be performed during type checking.

TLP isn't new. GHC' Haskell is leading the charge with the numerous language extentions developped over the las decate. Unfortunately, many of the techniques developed in the context of Haskell are not directly applicable to other programming languages. In particular, subtying ...

% 8. State Research Objectives

% 9. Create an Outline
% - (Ab)Using Implicits
% - Generalizing Scala's Singleton Types
% - Match Types
% - Performance-Based Evaluation

\lipsum[1]

\chapter{(Ab)Using Implicits}
\label{chap:ab-using-implicits}

In this chapter...

\subsection*{Attribution}
\citep{odersky2018simplicitly}

\section{Implicit Parameters: Overview}

\emph{Implicit parameters} offer a convenient way to write code without the need to pass all arguments explicitly.
The ability to omit arguments to functions gives rise to many interesting coding styles and patterns.
On every call to functions with implicit parameters, the compiler looks for an implicit definition in scope to satisfy the call.
So, instead of passing a parameter explicitly:

\explicitModulo

\noindent
We can mark a set of parameters as implicit (a single parameter in this example) and let the compiler retrieve the missing argument for us.
In the following example, |addm| is a method with one implicit parameter and |modulo| is an implicit definition:

\implicitModulo

The process of implicit parameter discovery performed by the compiler is called \emph{implicit resolution}.
The resolution algorithm looks for implicits in the current scope and in the companion objects of all classes associated with the query type.
In the previous example, the implicit definition is declared in the current scope.
Since that definition has type |Int|, the compiler resolves the method call by passing |modulo| automatically.

\subsubsection{The type class pattern}

Implicits can be used to implement type classes \citep{wadler1989howto} as a design pattern \citep{oliveira2010type}.
We give an example of an implementation of the |Ordering| type class.
This example consists of three parts:

\begin{enumerate}
  \item |Ordering[T]|, which is a regular trait with a single method, |compare|,
  \item the generic function |comp|, which compares two arguments and accepts an implicit argument, providing an \emph{implicit evidence} that these two values can be compared,
  \item the implicit definition |intOrdering|, which provides an \emph{instance} of the |Ordering| type class for integers.
\end{enumerate}

\ordExample

We have briefly introduced implicit parameters and showed who they can be used to avoid clutter in function applications.
In the next section, we present recursive implicit resolution.

\section{Recursive Implicit Resolution}

Implicit methods can themselves have implicit parameters.
For example, we can define the lexicographic list ordering as follows:

\ordListExample

\noindent
This definition is parametrized by the list's element type and by an ordering of that type, passed as an implicit parameter.
Since |listOrdering| is itself implicit, it defines a \emph{rule}: it allows the compiler to obtain an implicit |Ordering[List[T]]| given an implicit |Ordering[T]|, for any type |T|.

Parametrized implicit definitions can lead to recursive implicit resolution, for example, the compiler will use |listOrdering| twice to synthesize an implicit |Ordering[List[List[T]]]|.
This is where the (type-level) fun begins!

\subsubsection{Heterogeneous lists}

A heterogeneous list, or |HList| for short~\citep{kiselyov2004strongly}, is a datatype capable of storing data of different types.
In Scala, we can define the |HList| datatype as follows:

\hlistEnumDefinition
% enum HList:
%   case HNil()
%   case ::[H, T <: HList](head: H, tail: T)


\noindent
The |::| constructor offers an interesting symmetry between the term and type level, which allows |HList| types to capture the same structure that their term-level counterparts.
For example, the term |::(1, ::(2, HNil()))| can be typed as |::[1, ::[2, HNil]]|, which is a perfect reification of that term\footnotemark.
We can define type-level processing operations on |HList|s using implicits.
Each operation the form of a trait, the operation's entry point, and several implicit definitions, one for each "case" of the operation's algorithm.

\footnotetext{In this example, 1 and 2 are used both as term and type literals.}

\subsubsection{HList's remove}

Let us consider the remove operation on |HList|s in more details.

\memImplicitRemove
% trait Remove[V, Ps <: HList, Out <: HList]

% object Remove:
%   implicit def casehead[V, Ps <: HList]
%     : Remove[V, V :: Ps, Ps] = new Remove {}

%   implicit def casetail[V, Ph, Pt <: HList, Out <: HList]
%     (implicit ev: Remove[V, Pt, Out])
%     : Remove[V, Ph :: Pt, Ph :: Out] = new Remove {}

\noindent
The |Remove| trait takes 3 type parameters, 2 inputs, |V| (the element to remove) and |Ps| (the list), and one output, |Out|.
This trait is intended to be used as an implicit parameter with fixed input types, and a variable output type.

% def addEventListener(tpe: String, listener: Event => Unit): Unit

% type EventTypes = "mousedown" :: "mouseup" :: "mouseover" :: "mousewheel" :: "contextmenu" :: HNil

% From the intro:
% The first definition, |casehead|, specifies a fact: the result of removing |V| from the list |V::Ps| is |Ps|, which is expressed as an instance of |Remove[V, V::Ps, Ps]|.
% The second definition, |casetail|, specifies a rule: if the result of removing |V| from the list |Pt| is |Out|, the results of removing |V| from the list |Ph::Pt| is |Ph::Out| (which is expressed as in instance of |Remove[V, Ph::Pt, Ph::Out]|).
% When a user writes |ctx.free("mem")| on a |ctx| of type |Context["bool"::"mem"::HNil]|, the compiler uses |casehead| and |casetail| to compute a type |Out| such that |Out| is the results of removing |"mem"| from |"bool"::"mem"::HNil|.

\section{Priorities and Ambiguities}

|implicitly[Remove[1, 1 :: 2 :: 1 :: HNil, ?]]|
The Implicit Negation Pattern

\chapter{Generalizing Scala's Singleton Types}
\label{chap:generalizing-scala-s-singleton-types}
\subsection*{Attribution}
\citep{shmid2020coming}
\lipsum[1]

\chapter{Match Types}
\label{chap:match-types}
\subsection*{Attribution}
\citep{blanvillain2022type}
\input{article.tex}

\chapter{Performance-Based Evaluation}
\label{chap:performance-based-evaluation}
\lipsum[1]

\chapter{Conclusion}
\label{chap:conclusion}
\lipsum[1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%  Bibliography, Appendix, CV  %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\chapter{Type Soundness for System FM}
\renewenvironment{proof}{{\it Proof: }}{\qed} % Show proofs
\input{proofs/permutation.tex}
\input{proofs/weakening.tex}
\input{proofs/strengthening.tex}
\input{proofs/substitution.tex}
\input{proofs/disjointness-subtyping-exclusivity.tex}

\harpoonx{Definition of the auxiliary relation $\protect \⇌$, used to state inversion of subtyping.}

\begin{definition*}
  $\Γ \⊢ \S \⇌ \T$ (defined in \Cref{fig:harpoon}) represents evidence of the mutual subtyping between a match type $\S$ and a type $\T$ with the additional constraint that this evidence was exclusively constructed using pairwise applications of \emph{\SMatch1/2}, \emph{\SMatch3/4}, and \emph{\STrans} in both directions.
\end{definition*}

\input{proofs/inversion-of-subtyping.tex}
\input{proofs/canonical-forms.tex}
\input{proofs/inversion-of-typing.tex}
\input{proofs/minimum-types.tex}
\input{proofs/preservation.tex}
\input{proofs/progress.tex}

\backmatter
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{apalike}
\bibliography{bibliography}

\cleardoublepage
\thispagestyle{empty}
\phantomsection
\addcontentsline{toc}{chapter}{Curriculum Vitae}
\includepdf{olivier-blanvillain-resume.pdf}
\thispagestyle{empty}~

\end{document}
