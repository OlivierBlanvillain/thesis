\section{Introduction}

The Scala standard library contains a package to manipulate regular expressions.
This package is based on Java's implementation, and thus benefits from the high performance of the JVM's regex engine.
The Scala implementation innovates in its presentation: it uses the power and flexibility of Scala's pattern matching to offer a syntax that is both elegant and concise.
The package's documentation starts with the following example:

\regexDocumentation
% val date = new Regex("(\\d{4})-(\\d{2})-(\\d{2})")
% "2004-01-20" match
%   case date(year, month, day) =>
%     s"$year was a good year for PLs."

\noindent
The extractor pattern, |case date(y,m,d) =>|, replaces the need for manually indexing into the regular expression's capturing groups, and shields users from off-by-one error.

While the syntax of this example would undoubtedly make some non-Scala programmers envious, its type safety leaves much to be desired.
First of all, the \emph{number} of variable bindings in the extractor is entirely opaque to Scala's type system, and left to the discretion of the programmer.
Furthermore, the values that come out of capturing groups can be null (when using optional captures) and thus require an additional layer of validation.
Those shortcomings might appear benign on small examples, but can easily turn into bugs when dealing with a large-scale code base.

In this chapter, we propose a new design for Scala's regular expression library which provides a type-safe and null-safe mechanism for capturing group extraction.
Our design makes extensive use of match types, Scala~3 new feature for type-level programming, to statically analyze regular expressions during type checking and generate type-specialized extractors.
We build our interface to mimic Scala's original regular expression API so that Scala programmers can use it as a drop-in replacement and enjoy the additional safety with minimal migration costs.

\section{Architecture}

We present our library in terms of 3 components:

\begin{enumerate}
  \item The type-level capturing group analysis, which uses match types to inspect the user-provided regular expression and compute the corresponding tuple-based type representation (\Cref{sec:type-level}).

  \item The term-level capturing group processing, which extracts and sanitizes the output of the regex engine, in accordance with the previously computed type-level representation computed (\Cref{sec:term-level}).

  \item The user interface, which ties everything together to compile, execute, and extract the results of a regular expression, while providing type-safe and null-safe experience.
\end{enumerate}

We begin our presentation with the user interface, which takes the form of a relatively simple Scala class and companion object:

\regexUserLevel
% object Regex:
%   def apply[R <: String & Singleton](regex: R): Regex[Compile[R]] =
%     new Regex(regex)
%
% class Regex[P] private (val regex: String):
%   val pattern = Pattern.compile(regex)
%   def unapply(s: String): Option[P] =
%     val m = pattern.matcher(s)
%     if (m.matches())
%       val a = Array.tabulate(m.groupCount)(i => m.group(i + 1))
%       Some(transform[P](regex, a))
%     else
%       None

The |apply| method is the entry point of our library.
It takes a regular expression and returns an instance of |Regex|.
Instead of directly accepting a |String| argument, that method takes a type parameter, |R|, which will be inferred by the compiler, and allows us to get our hands on a type-level instance of the regular expression's string (the |Singleton| bound is necessary to guide Scala's type inference).
We use that type-level string to instantiate |Compile|, our type-level analysis component.

The implementation of the |Regex| class is straightforward.
Similar to its standard library counterpart, that class uses an instance of |java.util.regex.Pattern| to match the given input against the given regular expression, and to extract the content of the capturing groups when the matching succeeds.
These operations operations take place within the |unapply| method, which is the way to define custom pattern matching extractors in Scala \citep{emir2007matching}.

The main difference between Scala's original |Regex| implementation and ours lies in the signature of the |unapply| method, which determines the nature of extraction performed by that method.
By returning an optional tuple, we tell the compiler that a successful matching consists of exactly $n$ capturing groups, where $n$ is the tuple's arity, and that the type of those groups corresponds to the type of the tuple elements.
We take advantage of that flexibility to enrich the results of Java's regex engine by wrapping nullable values into options.
In our implementation, this is done via the |transform| method, which is our
term-level processing component.
As a result, our implementation never returns null values, which removes the null-checking burden from the user.

For instance, in the following example usage of our library, we use a regular expression with an optional capturing group to extract the integral and fractional parts of a rational number:

\regexRational
% val rational = Regex("(\\d+)\\.?(\\d+)?")
% "3.1415" match
%   case rational(i, Some(f)) =>
%     val n = i.size + f.size
%     s"This number is $n digits long"

\noindent
Here, we instantiates |Regex|'s type parameter to |P = (String, Option[String])|, which we then use in |unapply|'s return type to obtain a precise representation of the regex's capturing groups.
The resulting code is type-safe: if we change the pattern to omit the option unpacking (replacing |Some(f)| by |f|), the compiler would raise a type error on the call to |.size| (size is defined on strings but not options).

In the following section, we explain our technique to analysis regular expressions and statically compute a type-level representation of the regex's capturing groups (|P| in the example above).

\section{Type-Level}
\label{sec:type-level}

The purpose of our type-level component is two-fold:

\begin{enumerate}
  \item Identify the capturing groups of a regular expression.
  \item Determine which of those capturing groups are optional, that is, whether or not the regex engine could possibly assign null values for each of those groups.
\end{enumerate}

\noindent
The result of that type-level computation takes the form of a Scala tuple with |String| and |Option[String]| elements, depending of the nullability analysis.

We present our implementation incrementally, starting from a simple but incomplete solution, and progressively building up towards our final solution.

\subsection{Capturing Group Identification}

The first version of our type-level program is limited to capturing group identification.
The implementation is straightforward, it iterates through the regex's characters and accumulates a |String| type for every opening parenthesis:

\regexFirstIteration
% import compiletime.ops.string._
% import compiletime.ops.int.+
%
% type Compile[R <: String] =
%   Reverse[Loop[R, 0, Length[R], EmptyTuple]]
%
% type Loop[R <: String, Lo <: Int, Hi <: Int, Acc <: Tuple] <: Tuple =
%   Lo match
%     case Hi => Acc
%     case _  => CharAt[R, Lo] match
%       case "("  => Loop[R, Lo + 1, Hi, String *: Acc]
%       case "\\" => Loop[R, Lo + 2, Hi, Acc]
%       case _ => Loop[R, Lo + 1, Hi, Acc]

\noindent
The |Length| and |CharAt| types (from |ops.string|) are special-cased by the compiler: when their first argument is a known string literal, the compiler evaluates those types via their corresponding term-level implementation.
Similarly, the |+| type (from |ops.int|) allows us to manipulate integers just like we would at the term level.
The |EmptyTuple| and |*:| types are Scala~3's new generic representation of tuples.
Those types remove the need for heterogeneous lists and let us manipulate tuples directly.

\subsection{Out-Of-Bound Errors}

Attentive readers might have noticed that our handling of backslash, regex's escape character, might result in off-by-one errors.
Indeed, the |Loop| type terminates when |Lo = Hi|, but increases |Lo| by 2 to skip over escaped characters.

Be reassured, this is not an oversight!
Regular expressions with trailing backslashes are invalid and result in runtime crashes (reported as "unexpected internal error").
Even though detecting these types of errors at compile time is out of the scope of our library, doing so is still desirable.
If we invoke |Compile| on a regular expression with a trailing backslash, the compiler will run into a call to |charAt| with an out of bounds argument, catch the corresponding exception and report it as a compilation error, which is certainly better reporting that error at runtime.

\subsection{Non-Capturing Groups}
\label{subsec:non-capturing-groups}

Our first implementation of |Compile| treats every opening parenthesis as the start of a capturing group, which does not do honor to the syntax of Java's regular expression.
Indeed, Java also supports several other special constructs which start with an opening parenthesis, for instance:

\begin{itemize}
  \item non-capturing groups, |(?:X)|,
  \item lookaheads, |(?=X)| and |(?!X)|,
  \item lookbehinds, |(?<=X)| and |(?<!X)|.
\end{itemize}

\noindent
To correctly identify capturing groups (which can be either named, |(?<name>X)|, or unnamed, |(X)|), we must differentiate them from other special constructs.
Our second implementation (omitted) uses the following |IsCapturing| predicate type to rule out non-capturing groups:

\regexIsCapturing
% type IsCapturing[R <: String, At <: Int] <: Boolean =
%   CharAt[R, At] match
%     case "?" => CharAt[R, At + 1] match
%       case "<" => CharAt[R, At + 2] match
%         case "!" => false // zero-width negative lookbehind
%         case _ => true    // named-capturing group
%       case _ => false     // other non-capturing special constructs
%     case _ => true        // unnamed-capturing group

\noindent
Similar to our handling of backslash characters, this implementation intentionally does not guard against out-of-bounds errors, since these errors correspond to ill-formed regular expressions.

\subsection{Nullability Analysis}

Establishing the nullability of capturing groups is more complicated than it sounds.
At first glance, it seems that this is simply a matter of looking for regex quantifiers in suffix position\footnote{
For brevity, our presentation does not account for the regex alternative operator, which also influences the nullability of capturing groups and can appear in both prefix and suffix positions.
Similarly, we omit handling the "at least $n$ times" quantifiers which can lead to nullable capturing groups (when $n=0$).
Our implementation accounts for both operators.
}.
For instance, in the following naive implementation of |IsNullable|, we look for the first closing parenthesis and inspect the following characters to determine if a capturing group is nullable:

\regexNaiveIsNullable
% type IsNullable[R <: String, At <: Int, Hi <: Int] <: Boolean =
%   CharAt[R, At] match
%     case ")" => IsMarked[R, At + 1, Hi]
%     case _   => IsNullable[R, At + 1, Hi]
%
% type IsMarked[R <: String, At <: Int, Hi <: Int] <: Boolean =
%   At match
%     case Hi => false
%     case _ =>
%       CharAt[R, At] match
%         case "?" | "*" => true
%         case "+" => IsMarked[R, At + 1, Hi]
%         case _ => false

\noindent
Unfortunately, this naive solution is incorrect for regular expressions with nested capturing groups.
For example, in |(A(B)?)|, that solution incorrectly labels the first group as optional.
To overcome this problem, we update our solution to keep track of the number of opening and closing parentheses (|Lvl|), which allows us to differentiate closing parentheses of inner and outer groups:

\regexIsNullable
% type IsNullable[R <: String, At <: Int, Hi <: Int, Lvl <: Int] <: Boolean =
%   CharAt[R, At] match
%     case ")" => Lvl match
%       case 0 => IsMarked[R, At + 1, Hi]
%       case _ => IsNullable[R, At + 1, Hi, Lvl - 1]
%     case "(" => IsNullable[R, At + 1, Hi, Lvl + 1]
%     case "\\" => IsNullable[R, At + 2, Hi, Lvl]
%     case _    => IsNullable[R, At + 1, Hi, Lvl]

Nested capturing groups bring another complication to the nullability analysis, which is caused by the interaction between inner and outer groups.
When an outer group is deemed optional, this overrides the nullability of all its inner groups, which also become optional.
For instance, in |(A(B))?|, both the first (|A(B)|) and the second (|B|) capturing group are optional.

We handle nested groups by updated our algorithm to operate in two different modes while iterating through the regex's characters.
Our algorithm can either be outside of an optional group (|Opt=0|), in which case it computes nullability of newly encountered groups via |IsNullable|, or inside an optional group (|Opt>0|), in which case it treats every group as nullable.

With this latest improvement, we advance our implementation to its final iteration (we omit usages of |IsCapturing|, from \Cref{subsec:non-capturing-groups}, for brevity):

\regexLastIteration
% type Loop[R <: String, Lo <: Int, Hi <: Int, Acc <: Tuple, Opt <: Int] =
%   Lo match
%     case Hi => Acc
%     case _  => CharAt[R, Lo] match
%       case ")" => Loop[R, Lo + 1, Hi, Acc, Max[0, Opt - 1]]
%       case "(" =>
%         Opt match
%           case 0 => IsNullable[R, Lo + 1, Hi, 0] match
%             case true  => Loop[R, Lo + 1, Hi, Option[String] *: Acc, 1]
%             case false => Loop[R, Lo + 1, Hi, Acc, 0]
%           case _ => Loop[R, Lo + 1, Hi, Option[String] *: Acc, Opt + 1]
%       case "\\" => Loop[R, Lo + 2, Hi, Acc, Opt]
%       case _ => Loop[R, Lo + 1, Hi, Acc, Opt]

This concludes the development of our nullability analysis and completes our presentation of the type-level component of our library.
Despite the scarcity of Scala's standard library at the type level, we managed to achieve our ends while keeping our implementation relatively concise and, hopefully, understandable.
In its final iteration, our capturing group analysis is, to the best of our knowledge, on par with Java's implementation of regular expression.

\section{Term-Level}
\label{sec:term-level}

The term-level component of our library is in charge of sanitizing and packaging the results of regular expression matchings.
Concretely, this component's job consists in transforming the string array that comes out of the regex engine into an appropriately sized tuple, with nullable elements wrapped in options.
That transformation must conform to the representation computed at the type level.

In Scala, all type parameters are erased, which can lead so some friction when trying to write programs whose execution \emph{depends} on a type, such as in the problem at hand.
In this section, we propose two different solutions to that problem.

\begin{enumerate}
  \item In \Cref{subsec:we-ain-t-need-no-dependent-types}, we proceed by sheer force of code duplication: we translate the entirety of our type-level algorithm into term-level functions and use a cast to correlate the two.

  \item In \Cref{subsec:implicit-based-extractor-synthesis}, we show...
\end{enumerate}

\subsection{We Ain't Need No Dependent Types!}
\label{subsec:we-ain-t-need-no-dependent-types}

The first implementation of our term-level component duplicates the type-level definitions presented in the previous section to compute a list of sanitizing functions that correspond to the given regex's capturing groups.
In a nutshell, instead of accumulating |String| and |Option[String]| types, we rewrite the outer loop of our algorithm to accumulate identity functions and eta-expansions of the option constructor:

\regexTermLvlLoop
% val identity: String => Any = { x => assert(x != null); x }
% type Accumulator = List[String => Any]
%
% def loop(r: String, lo: Int, hi: Int, acc: Accumulator, opt: Int): Accumulator =
%   lo match
%     case `hi` => acc
%     case _  => r.charAt(lo) match
%       case ')' => loop(r, lo + 1, hi, acc, 0.max(opt - 1))
%       case '(' =>
%         opt match
%           case 0 => isNullable(r, lo + 1, hi, 0) match
%             case true  => loop(r, lo + 1, hi, Option.apply :: acc, 1)
%             case false => loop(r, lo + 1, hi, identity :: acc, 0)
%           case _ => loop(r, lo + 1, hi, Option.apply :: acc, opt + 1)
%       case '\\' => loop(r, lo + 2, hi, acc, opt)
%       case _ => loop(r, lo + 1, hi, acc, opt)

\noindent
After having computed those functions, we simply do a pointwise application with the raw output of the regex engine, package the result into a tuple, \emph{et voilÃ !}

\regexTransform
% def transform[P](pattern: String, arr: Array[String]): P =
%   val fs = loop(pattern, 0, pattern.length, Nil, 0).reverse
%   val ts = Tuple.fromArray(arr.zip(fs).map { (x, f) => f(x) })
%   assert(arr.size == fs.size, "Unexpected number of capturing groups")
%   ts.asInstanceOf[P]

\emph{In principle}, Scala~3's type system is capable of doing a lightweight form of dependent typing (\Cref{subsec:a-lightweight-form-of-dependent-typing}), where it...

\begin{lstlisting}
def isMarked
  [R <: String, At <: Int, Hi <: Int]
  (r: R, at: At, hi: Hi)
  : IsMarked[R, At, Hi]
\end{lstlisting}

\subsection{Implicit-Based Extractor Synthesis}
\label{subsec:implicit-based-extractor-synthesis}

\section{Evaluation}

In this section...
